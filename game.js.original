class IdleAnts {
    constructor() {
        // Game state
        this.resources = {
            food: 0,
            displayFood: 0 // For smooth animation
        };
        this.stats = {
            ants: 1,
            maxAnts: 10,
            foodPerClick: 1,
            foodPerSecond: 0,
            antCost: 10,
            foodUpgradeCost: 50,
            expandCost: 100,
            foodMultiplier: 1
        };
        
        // Pixi.js setup
        this.app = new PIXI.Application({
            background: '#78AB46', // Grass green background
            resizeTo: document.getElementById('game-canvas-container'),
        });
        document.getElementById('game-canvas-container').appendChild(this.app.view);
        
        // Load assets
        this.loadAssets().then(() => {
            this.setupGame();
            this.setupEventListeners();
            this.startGameLoop();
        });
    }
    
    async loadAssets() {
        return new Promise((resolve) => {
            // Create a loader
            const loader = PIXI.Assets;
            
            // Create sprites from URLs (these will be placeholder URLs until we add real images)
            // For now, we'll create textures programmatically but with better graphics
            
            // Create ant texture - more detailed ant
            const antGraphics = new PIXI.Graphics();
            // Ant body - dark brown
            antGraphics.beginFill(0x3D2817);
            antGraphics.drawEllipse(0, 0, 6, 10);
            antGraphics.endFill();
            
            // Ant head - darker
            antGraphics.beginFill(0x2A1B10);
            antGraphics.drawCircle(0, -12, 5);
            antGraphics.endFill();
            
            // Ant legs
            antGraphics.lineStyle(1, 0x3D2817);
            // Left legs
            antGraphics.moveTo(-6, -5);
            antGraphics.lineTo(-12, -10);
            antGraphics.moveTo(-6, 0);
            antGraphics.lineTo(-14, 0);
            antGraphics.moveTo(-6, 5);
            antGraphics.lineTo(-12, 10);
            // Right legs
            antGraphics.moveTo(6, -5);
            antGraphics.lineTo(12, -10);
            antGraphics.moveTo(6, 0);
            antGraphics.lineTo(14, 0);
            antGraphics.moveTo(6, 5);
            antGraphics.lineTo(12, 10);
            
            // Antennae
            antGraphics.moveTo(-2, -12);
            antGraphics.lineTo(-6, -20);
            antGraphics.moveTo(2, -12);
            antGraphics.lineTo(6, -20);
            
            // Create food texture - make it look like bread crumbs/seeds
            const foodGraphics = new PIXI.Graphics();
            foodGraphics.beginFill(0xEAD2AC); // Light beige
            foodGraphics.drawCircle(0, 0, 5);
            foodGraphics.endFill();
            foodGraphics.beginFill(0xD9BF93); // Darker beige for shadow
            foodGraphics.drawCircle(1, 1, 3);
            foodGraphics.endFill();
            
            // Create nest texture - more detailed mound
            const nestGraphics = new PIXI.Graphics();
            // Main mound
            nestGraphics.beginFill(0x8B4513);
            nestGraphics.drawCircle(0, 0, 30);
            nestGraphics.endFill();
            
            // Entrance hole
            nestGraphics.beginFill(0x3D2817);
            nestGraphics.drawCircle(0, 0, 10);
            nestGraphics.endFill();
            
            // Add some texture to the mound with lighter spots
            nestGraphics.beginFill(0xA86032);
            nestGraphics.drawCircle(-15, -10, 8);
            nestGraphics.drawCircle(10, 15, 6);
            nestGraphics.drawCircle(15, -5, 5);
            nestGraphics.endFill();
            
            // Create ground texture
            const groundGraphics = new PIXI.Graphics();
            groundGraphics.beginFill(0x8B5A2B); // Soil color
            groundGraphics.drawRect(0, 0, 100, 100);
            groundGraphics.endFill();
            
            // Add some variation to the ground
            groundGraphics.beginFill(0x7C5028); // Darker soil spots
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * 100;
                const y = Math.random() * 100;
                const size = 2 + Math.random() * 6;
                groundGraphics.drawCircle(x, y, size);
            }
            groundGraphics.endFill();
            
            // Convert graphics to textures
            this.antTexture = this.app.renderer.generateTexture(antGraphics);
            this.foodTexture = this.app.renderer.generateTexture(foodGraphics);
            this.nestTexture = this.app.renderer.generateTexture(nestGraphics);
            this.groundTexture = this.app.renderer.generateTexture(groundGraphics);
            
            resolve();
        });
    }
    
    setupGame() {
        // Create background with tiled ground texture
        this.createBackground();
        
        // Create containers for game objects
        this.antsContainer = new PIXI.Container();
        this.foodContainer = new PIXI.Container();
        this.nestContainer = new PIXI.Container();
        
        this.app.stage.addChild(this.nestContainer);
        this.app.stage.addChild(this.foodContainer);
        this.app.stage.addChild(this.antsContainer);
        
        // Create nest
        const nest = new PIXI.Sprite(this.nestTexture);
        nest.anchor.set(0.5);
        nest.x = this.app.screen.width / 2;
        nest.y = this.app.screen.height / 2;
        this.nestPosition = { x: nest.x, y: nest.y };
        
        this.nestContainer.addChild(nest);
        
        // Create initial ants
        this.ants = [];
        this.createAnt();
        
        // Create food sources
        this.foods = [];
        this.createFood(5);
    }
    
    createBackground() {
        // Create a tiled background with the ground texture
        this.background = new PIXI.TilingSprite(
            this.groundTexture,
            this.app.screen.width,
            this.app.screen.height
        );
        
        this.app.stage.addChildAt(this.background, 0);
        
        // Update the size when the window is resized
        window.addEventListener('resize', () => {
            this.background.width = this.app.screen.width;
            this.background.height = this.app.screen.height;
        });
    }
    
    setupEventListeners() {
        // Canvas click for manual food collection
        this.app.view.addEventListener('click', (e) => {
            const rect = this.app.view.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            this.addFood({ x, y, clickPlaced: true }); // Mark as manually placed
            this.resources.food += this.stats.foodPerClick;
            this.updateUI();
        });
        
        // Add hover effect
        this.hoverIndicator = new PIXI.Graphics();
        this.app.stage.addChild(this.hoverIndicator);
        
        // Track mouse movement for hover effect
        this.app.view.addEventListener('mousemove', (e) => {
            const rect = this.app.view.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            this.updateHoverIndicator(x, y);
        });
        
        // Remove hover effect when mouse leaves the canvas
        this.app.view.addEventListener('mouseleave', () => {
            this.hoverIndicator.clear();
        });
        
        // UI button click events
        document.getElementById('buy-ant').addEventListener('click', () => this.buyAnt());
        document.getElementById('upgrade-food').addEventListener('click', () => this.upgradeFood());
        document.getElementById('expand-colony').addEventListener('click', () => this.expandColony());
    }
    
    updateHoverIndicator(x, y) {
        // Clear previous drawing
        this.hoverIndicator.clear();
        
        // Draw a subtle circular indicator where food would be placed
        this.hoverIndicator.lineStyle(1, 0xFFFFFF, 0.5);
        this.hoverIndicator.drawCircle(x, y, 15);
        this.hoverIndicator.endFill();
        
        // Add a pulsing inner circle
        const pulse = 0.5 + Math.sin(performance.now() / 200) * 0.3;
        this.hoverIndicator.lineStyle(1, 0xFFD700, pulse);
        this.hoverIndicator.drawCircle(x, y, 8);
        
        // Add a small dot at the center
        this.hoverIndicator.beginFill(0xFFD700, 0.7);
        this.hoverIndicator.drawCircle(x, y, 2);
        this.hoverIndicator.endFill();
    }
    
    startGameLoop() {
        // Update UI initially
        this.updateUI();
        
        // Start ticker
        this.app.ticker.add(() => this.gameLoop());
        
        // Set up idle resource generation
        setInterval(() => {
            this.resources.food += this.stats.foodPerSecond;
            this.updateUI();
        }, 1000);
    }
    
    gameLoop() {
        // Smooth counter animations
        this.animateCounters();
        
        // Move ants
        this.ants.forEach(ant => this.moveAnt(ant));
        
        // Animate food items
        this.foods.forEach(food => {
            if (food.glowPulse) {
                food.glowCounter += 0.03;
                const pulseFactor = 0.8 + Math.sin(food.glowCounter) * 0.2;
                food.children[0].scale.set(pulseFactor);
                food.children[0].alpha = 0.5 + Math.sin(food.glowCounter) * 0.3;
            }
        });
        
        // Check for food collection
        this.checkFoodCollection();
    }
    
    animateCounters() {
        // Smoothly animate the food counter
        const diff = this.resources.food - this.resources.displayFood;
        
        if (Math.abs(diff) > 0.01) {
            this.resources.displayFood += diff * 0.1;
            document.getElementById('food-count').textContent = Math.floor(this.resources.displayFood);
        } else {
            this.resources.displayFood = this.resources.food;
            document.getElementById('food-count').textContent = Math.floor(this.resources.food);
        }
    }
    
    createAnt() {
        const ant = new PIXI.Sprite(this.antTexture);
        ant.anchor.set(0.5);
        ant.x = this.nestPosition.x;
        ant.y = this.nestPosition.y;
        
        // Ant properties
        ant.speed = 1 + Math.random() * 0.5;
        ant.targetFood = null;
        ant.hasFood = false;
        ant.scale.set(0.8 + Math.random() * 0.4); // Random size variation
        
        // Random starting velocity
        const angle = Math.random() * Math.PI * 2;
        ant.vx = Math.cos(angle) * ant.speed;
        ant.vy = Math.sin(angle) * ant.speed;
        
        // Add a slight pulsing animation
        ant.animationCounter = Math.random() * Math.PI * 2; // Random start phase
        
        // Add a shadow
        const shadow = new PIXI.Graphics();
        shadow.beginFill(0x000000, 0.2);
        shadow.drawEllipse(0, 0, 8, 4);
        shadow.endFill();
        shadow.y = 8; // Position under the ant
        ant.addChild(shadow);
        
        this.antsContainer.addChild(ant);
        this.ants.push(ant);
        
        // Add a spawning effect
        this.createSpawnEffect(ant.x, ant.y);
        
        // Update UI
        this.updateUI();
    }
    
    createSpawnEffect(x, y) {
        // Create a starburst effect when an ant spawns
        const burst = new PIXI.Container();
        burst.x = x;
        burst.y = y;
        
        // Create several particles that expand outward
        for (let i = 0; i < 8; i++) {
            const particle = new PIXI.Graphics();
            particle.beginFill(0xFFFFFF);
            particle.drawCircle(0, 0, 2);
            particle.endFill();
            
            const angle = (i / 8) * Math.PI * 2;
            particle.vx = Math.cos(angle) * 2;
            particle.vy = Math.sin(angle) * 2;
            particle.alpha = 1;
            
            burst.addChild(particle);
        }
        
        this.app.stage.addChild(burst);
        
        // Animate the burst
        let elapsed = 0;
        const animate = () => {
            elapsed += 0.1;
            
            // Update each particle
            for (let i = 0; i < burst.children.length; i++) {
                const particle = burst.children[i];
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.alpha -= 0.05;
                
                if (particle.alpha <= 0) {
                    particle.alpha = 0;
                }
            }
            
            // Remove the burst when complete
            if (elapsed >= 1) {
                this.app.stage.removeChild(burst);
                return;
            }
            
            requestAnimationFrame(animate);
        };
        
        animate();
    }
    
    createFood(count = 1) {
        for (let i = 0; i < count; i++) {
            const x = Math.random() * this.app.screen.width;
            const y = Math.random() * this.app.screen.height;
            this.addFood({ x, y });
        }
    }
    
    addFood(position) {
        const food = new PIXI.Sprite(this.foodTexture);
        food.anchor.set(0.5);
        food.x = position.x;
        food.y = position.y;
        
        // Add visual enhancements
        food.scale.set(0.7 + Math.random() * 0.6); // Random size
        food.rotation = Math.random() * Math.PI * 2; // Random rotation
        
        // Add a glowing effect to make food more visible
        const glow = new PIXI.Graphics();
        glow.beginFill(0xFFFF99, 0.3);
        glow.drawCircle(0, 0, 10);
        glow.endFill();
        glow.alpha = 0.6;
        food.addChild(glow);
        
        // Add a shadow
        const shadow = new PIXI.Graphics();
        shadow.beginFill(0x000000, 0.2);
        shadow.drawEllipse(0, 0, 6, 3);
        shadow.endFill();
        shadow.y = 5; // Position under the food
        food.addChild(shadow);
        
        // Add a slight pulsing animation to glow
        food.glowPulse = true;
        food.glowCounter = Math.random() * Math.PI * 2; // Random start phase
        
        this.foodContainer.addChild(food);
        this.foods.push(food);
        
        // Add a spawn effect for manually placed food
        if (position.clickPlaced) {
            this.createFoodSpawnEffect(position.x, position.y);
        }
    }
    
    createFoodSpawnEffect(x, y) {
        // Create a ripple effect when food is placed
        const ripple = new PIXI.Graphics();
        ripple.lineStyle(2, 0xFFFFFF, 0.8);
        ripple.drawCircle(0, 0, 5);
        ripple.x = x;
        ripple.y = y;
        
        this.app.stage.addChild(ripple);
        
        // Animate the ripple
        let elapsed = 0;
        const animate = () => {
            elapsed += 0.1;
            
            // Expand and fade the ripple
            ripple.scale.set(1 + elapsed * 2);
            ripple.alpha = 1 - elapsed;
            
            // Remove when complete
            if (elapsed >= 1) {
                this.app.stage.removeChild(ripple);
                return;
            }
            
            requestAnimationFrame(animate);
        };
        
        animate();
    }
    
    moveAnt(ant) {
        // Animate the ant's pulsing effect
        ant.animationCounter += 0.05;
        const pulseFactor = 1 + Math.sin(ant.animationCounter) * 0.05;
        ant.scale.set(ant.scale.x * pulseFactor, ant.scale.y * pulseFactor);
        
        // If ant has food, head back to nest
        if (ant.hasFood) {
            const dx = this.nestPosition.x - ant.x;
            const dy = this.nestPosition.y - ant.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Normalize and apply speed
            ant.vx = (dx / distance) * ant.speed;
            ant.vy = (dy / distance) * ant.speed;
            
            // Rotate ant to face direction of movement
            ant.rotation = Math.atan2(ant.vy, ant.vx);
            
            // If close to nest, drop food
            if (distance < 10) {
                ant.hasFood = false;
                this.resources.food += this.stats.foodMultiplier;
                this.updateUI();
                
                // Add food drop effect at nest
                this.createFoodDropEffect(this.nestPosition.x, this.nestPosition.y);
            }
        } 
        // If ant doesn't have food, look for food or wander
        else {
            // If ant doesn't have a target food, find one or continue wandering
            if (!ant.targetFood && this.foods.length > 0 && Math.random() < 0.02) {
                const randomFoodIndex = Math.floor(Math.random() * this.foods.length);
                ant.targetFood = this.foods[randomFoodIndex];
            }
            
            if (ant.targetFood) {
                const dx = ant.targetFood.x - ant.x;
                const dy = ant.targetFood.y - ant.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Normalize and apply speed
                ant.vx = (dx / distance) * ant.speed;
                ant.vy = (dy / distance) * ant.speed;
                
                // Rotate ant to face direction of movement
                ant.rotation = Math.atan2(ant.vy, ant.vx);
                
                // If food no longer exists, clear target
                if (!this.foods.includes(ant.targetFood)) {
                    ant.targetFood = null;
                }
                // If ant reaches food, collect it
                else if (distance < 5) {
                    this.collectFood(ant, ant.targetFood);
                }
            } else {
                // Random movement when wandering
                if (Math.random() < 0.05) {
                    const angle = Math.random() * Math.PI * 2;
                    ant.vx = Math.cos(angle) * ant.speed;
                    ant.vy = Math.sin(angle) * ant.speed;
                }
                
                // Rotate ant to face direction of movement
                ant.rotation = Math.atan2(ant.vy, ant.vx);
            }
        }
        
        // Apply movement
        ant.x += ant.vx;
        ant.y += ant.vy;
        
        // Boundary checking and wrapping
        const padding = 20;
        if (ant.x < -padding) ant.x = this.app.screen.width + padding;
        if (ant.x > this.app.screen.width + padding) ant.x = -padding;
        if (ant.y < -padding) ant.y = this.app.screen.height + padding;
        if (ant.y > this.app.screen.height + padding) ant.y = -padding;
    }
    
    createFoodDropEffect(x, y) {
        // Create a small particle effect when food is dropped at the nest
        const particles = new PIXI.Container();
        particles.x = x;
        particles.y = y;
        
        // Create food particles
        for (let i = 0; i < 5; i++) {
            const particle = new PIXI.Graphics();
            particle.beginFill(0xEAD2AC);
            particle.drawCircle(0, 0, 2);
            particle.endFill();
            
            // Random velocity upward
            particle.vx = (Math.random() - 0.5) * 2;
            particle.vy = -2 - Math.random() * 2;
            particle.gravity = 0.1;
            
            particles.addChild(particle);
        }
        
        this.app.stage.addChild(particles);
        
        // Animate the particles
        let elapsed = 0;
        const animate = () => {
            elapsed += 0.1;
            
            // Update each particle
            for (let i = 0; i < particles.children.length; i++) {
                const particle = particles.children[i];
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vy += particle.gravity; // Apply gravity
                particle.alpha -= 0.03;
            }
            
            // Remove when complete
            if (elapsed >= 1) {
                this.app.stage.removeChild(particles);
                return;
            }
            
            requestAnimationFrame(animate);
        };
        
        animate();
    }
    
    checkFoodCollection() {
        for (let i = 0; i < this.ants.length; i++) {
            const ant = this.ants[i];
            
            if (ant.hasFood || ant.targetFood) continue;
            
            for (let j = 0; j < this.foods.length; j++) {
                const food = this.foods[j];
                const dx = food.x - ant.x;
                const dy = food.y - ant.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 10) {
                    this.collectFood(ant, food);
                    break;
                }
            }
        }
    }
    
    collectFood(ant, food) {
        // Remove the food from the game
        const index = this.foods.indexOf(food);
        if (index > -1) {
            this.foods.splice(index, 1);
            this.foodContainer.removeChild(food);
        }
        
        // Mark ant as carrying food
        ant.hasFood = true;
        ant.targetFood = null;
        
        // Create a small food particle effect on collection
        this.createFoodCollectEffect(ant.x, ant.y);
        
        // Add a new food source randomly
        if (Math.random() < 0.7) {
            this.createFood();
        }
    }
    
    createFoodCollectEffect(x, y) {
        // Small sparkle effect when food is collected
        const sparkle = new PIXI.Graphics();
        sparkle.beginFill(0xFFFF99, 0.8);
        
        // Create a star shape (since drawStar doesn't exist)
        const points = [];
        const outerRadius = 5;
        const innerRadius = 2;
        const totalPoints = 5;
        
        for (let i = 0; i < totalPoints * 2; i++) {
            const radius = i % 2 === 0 ? outerRadius : innerRadius;
            const angle = (i / (totalPoints * 2)) * Math.PI * 2;
            points.push(
                radius * Math.cos(angle),
                radius * Math.sin(angle)
            );
        }
        
        sparkle.drawPolygon(points);
        sparkle.endFill();
        sparkle.x = x;
        sparkle.y = y;
        
        this.app.stage.addChild(sparkle);
        
        // Animate the sparkle
        let elapsed = 0;
        const animate = () => {
            elapsed += 0.1;
            
            // Fade out and rotate the sparkle
            sparkle.alpha = 1 - elapsed;
            sparkle.rotation += 0.2;
            sparkle.scale.set(1 + elapsed);
            
            // Remove when complete
            if (elapsed >= 1) {
                this.app.stage.removeChild(sparkle);
                return;
            }
            
            requestAnimationFrame(animate);
        };
        
        animate();
    }
    
    buyAnt() {
        if (this.resources.food >= this.stats.antCost && this.stats.ants < this.stats.maxAnts) {
            this.resources.food -= this.stats.antCost;
            this.stats.ants += 1;
            this.stats.foodPerSecond = this.stats.ants * 0.5;
            this.stats.antCost = Math.floor(this.stats.antCost * 1.5);
            
            this.createAnt();
            this.updateUI();
            this.showUpgradeEffect('buy-ant', 'New ant added!');
        }
    }
    
    upgradeFood() {
        if (this.resources.food >= this.stats.foodUpgradeCost) {
            this.resources.food -= this.stats.foodUpgradeCost;
            this.stats.foodMultiplier += 0.5;
            this.stats.foodPerClick = Math.ceil(this.stats.foodPerClick * 1.5);
            this.stats.foodUpgradeCost = Math.floor(this.stats.foodUpgradeCost * 2);
            
            this.updateUI();
            this.showUpgradeEffect('upgrade-food', 'Food collection upgraded!');
        }
    }
    
    expandColony() {
        if (this.resources.food >= this.stats.expandCost) {
            this.resources.food -= this.stats.expandCost;
            this.stats.maxAnts += 5;
            this.stats.expandCost = Math.floor(this.stats.expandCost * 2);
            
            this.updateUI();
            this.showUpgradeEffect('expand-colony', 'Colony expanded!');
            
            // Visual effect - make the nest slightly larger
            const nest = this.nestContainer.children[0];
            const currentScale = nest.scale.x;
            nest.scale.set(currentScale * 1.1);
            
            // Animate the nest scaling
            const originalScale = currentScale;
            const targetScale = currentScale * 1.1;
            let progress = 0;
            
            const animateNest = () => {
                progress += 0.05;
                
                if (progress >= 1) {
                    nest.scale.set(targetScale);
                    return;
                }
                
                // Apply easing
                const easedProgress = Math.sin(progress * Math.PI / 2);
                nest.scale.set(originalScale + (targetScale - originalScale) * easedProgress);
                
                requestAnimationFrame(animateNest);
            };
            
            animateNest();
        }
    }
    
    showUpgradeEffect(buttonId, message) {
        // Create a floating message
        const button = document.getElementById(buttonId);
        const buttonRect = button.getBoundingClientRect();
        
        const messageEl = document.createElement('div');
        messageEl.className = 'upgrade-message';
        messageEl.textContent = message;
        
        // Position near the button
        messageEl.style.position = 'absolute';
        messageEl.style.left = `${buttonRect.left + buttonRect.width / 2}px`;
        messageEl.style.top = `${buttonRect.top - 10}px`;
        messageEl.style.transform = 'translate(-50%, -100%)';
        messageEl.style.backgroundColor = 'rgba(255, 215, 0, 0.9)';
        messageEl.style.color = '#333';
        messageEl.style.padding = '5px 10px';
        messageEl.style.borderRadius = '20px';
        messageEl.style.fontWeight = 'bold';
        messageEl.style.zIndex = '100';
        messageEl.style.opacity = '0';
        messageEl.style.transition = 'all 0.5s ease';
        
        document.body.appendChild(messageEl);
        
        // Animate the message
        setTimeout(() => {
            messageEl.style.opacity = '1';
            messageEl.style.top = `${buttonRect.top - 30}px`;
        }, 10);
        
        // Remove after animation
        setTimeout(() => {
            messageEl.style.opacity = '0';
            messageEl.style.top = `${buttonRect.top - 50}px`;
            
            setTimeout(() => {
                document.body.removeChild(messageEl);
            }, 500);
        }, 1500);
        
        // Add a flash effect to the button
        button.style.backgroundColor = '#FFD700';
        button.style.transform = 'scale(1.05)';
        
        setTimeout(() => {
            button.style.backgroundColor = '';
            button.style.transform = '';
        }, 300);
    }
    
    updateUI() {
        // Only update other counters, food is handled in the animation loop
        document.getElementById('ant-count').textContent = this.stats.ants;
        document.getElementById('ant-max').textContent = this.stats.maxAnts;
        
        // Update costs
        document.getElementById('ant-cost').textContent = this.stats.antCost;
        document.getElementById('food-upgrade-cost').textContent = this.stats.foodUpgradeCost;
        document.getElementById('expand-cost').textContent = this.stats.expandCost;
        
        // Enable/disable buttons based on resources
        document.getElementById('buy-ant').disabled = 
            this.resources.food < this.stats.antCost || this.stats.ants >= this.stats.maxAnts;
        document.getElementById('upgrade-food').disabled = 
            this.resources.food < this.stats.foodUpgradeCost;
        document.getElementById('expand-colony').disabled = 
            this.resources.food < this.stats.expandCost;
    }
}

// Initialize the game when page loads
window.addEventListener('load', () => {
    const game = new IdleAnts();
}); 